[](https://pytorch.org/)
  * Learn 
[ Get Started Run PyTorch locally or get started quickly with one of the supported cloud platforms ](https://pytorch.org/get-started) [ Tutorials Whats new in PyTorch tutorials ](https://pytorch.org/tutorials) [ Learn the Basics Familiarize yourself with PyTorch concepts and modules ](https://pytorch.org/tutorials/beginner/basics/intro.html) [ PyTorch Recipes Bite-size, ready-to-deploy PyTorch code examples ](https://pytorch.org/tutorials/recipes/recipes_index.html) [ Intro to PyTorch - YouTube Series Master PyTorch basics with our engaging YouTube tutorial series ](https://pytorch.org/tutorials/beginner/introyt.html)
  * Ecosystem 
[ Tools Learn about the tools and frameworks in the PyTorch Ecosystem ](https://pytorch.org/ecosystem) [ Community Join the PyTorch developer community to contribute, learn, and get your questions answered ](https://pytorch.org/#community-module) [ Forums A place to discuss PyTorch code, issues, install, research ](https://discuss.pytorch.org/) [ Developer Resources Find resources and get questions answered ](https://pytorch.org/resources) [ Contributor Awards - 2024 Award winners announced at this year's PyTorch Conference ](https://pytorch.org/ecosystem/contributor-awards-2024)
  * Edge 
[ About PyTorch Edge Build innovative and privacy-aware AI experiences for edge devices ](https://pytorch.org/edge) [ ExecuTorch End-to-end solution for enabling on-device inference capabilities across mobile and edge devices ](https://pytorch.org/executorch-overview) [ ExecuTorch Docs ](https://pytorch.org/executorch/stable/index.html)
  * Docs 
[ PyTorch Explore the documentation for comprehensive guidance on how to use PyTorch ](https://pytorch.org/docs/stable/index.html) [ PyTorch Domains Read the PyTorch Domains documentation to learn more about domain-specific libraries ](https://pytorch.org/pytorch-domains)
  * Blogs & News 
[ PyTorch Blog Catch up on the latest technical news and happenings ](https://pytorch.org/blog/) [ Community Blog Stories from the PyTorch ecosystem ](https://pytorch.org/community-blog) [ Videos Learn about the latest PyTorch tutorials, new, and more  ](https://pytorch.org/videos)[ Community Stories Learn how our community solves real, everyday machine learning problems with PyTorch ](https://pytorch.org/community-stories) [ Events Find events, webinars, and podcasts ](https://pytorch.org/events) [ Newsletter Stay up-to-date with the latest updates ](https://pytorch.org/newsletter)
  * About 
[ PyTorch Foundation Learn more about the PyTorch Foundation ](https://pytorch.org/foundation) [ Governing Board ](https://pytorch.org/governing-board) [ Cloud Credit Program ](https://pytorch.org/credits) [ Technical Advisory Council ](https://pytorch.org/tac) [ Staff ](https://pytorch.org/staff) [ Contact Us ](https://pytorch.org/contact-us)
  * [ Become a Member ](https://pytorch.org/join)
  * [ ](https://github.com/pytorch/pytorch)


[](https://docs.pytorch.org/docs/stable/library.html)
Table of Contents [](https://docs.pytorch.org/docs/stable/library.html)
[2.7 ▼](https://pytorch.org/docs/versions.html)
|  | [×](javascript:void\(0\) "Clear search box")  
---|---  
search |   
Custom Search
|  Sort by: Relevance Relevance Date  
---|---  
Google Search  Classic Search 
Community[ - ][ + ]
  * [PyTorch Governance | Build + CI](https://docs.pytorch.org/docs/stable/community/build_ci_governance.html)
  * [PyTorch Contribution Guide](https://docs.pytorch.org/docs/stable/community/contribution_guide.html)
  * [PyTorch Design Philosophy](https://docs.pytorch.org/docs/stable/community/design.html)
  * [PyTorch Governance | Mechanics](https://docs.pytorch.org/docs/stable/community/governance.html)
  * [PyTorch Governance | Maintainers](https://docs.pytorch.org/docs/stable/community/persons_of_interest.html)


Developer Notes[ - ][ + ]
  * [Automatic Mixed Precision examples](https://docs.pytorch.org/docs/stable/notes/amp_examples.html)
  * [Autograd mechanics](https://docs.pytorch.org/docs/stable/notes/autograd.html)
  * [Broadcasting semantics](https://docs.pytorch.org/docs/stable/notes/broadcasting.html)
  * [CPU threading and TorchScript inference](https://docs.pytorch.org/docs/stable/notes/cpu_threading_torchscript_inference.html)
  * [CUDA semantics](https://docs.pytorch.org/docs/stable/notes/cuda.html)
  * [PyTorch Custom Operators Landing Page](https://docs.pytorch.org/docs/stable/notes/custom_operators.html)
  * [Distributed Data Parallel](https://docs.pytorch.org/docs/stable/notes/ddp.html)
  * [Extending PyTorch](https://docs.pytorch.org/docs/stable/notes/extending.html)
  * [Extending torch.func with autograd.Function](https://docs.pytorch.org/docs/stable/notes/extending.func.html)
  * [Frequently Asked Questions](https://docs.pytorch.org/docs/stable/notes/faq.html)
  * [FSDP Notes](https://docs.pytorch.org/docs/stable/notes/fsdp.html)
  * [Getting Started on Intel GPU](https://docs.pytorch.org/docs/stable/notes/get_start_xpu.html)
  * [Gradcheck mechanics](https://docs.pytorch.org/docs/stable/notes/gradcheck.html)
  * [HIP (ROCm) semantics](https://docs.pytorch.org/docs/stable/notes/hip.html)
  * [Features for large-scale deployments](https://docs.pytorch.org/docs/stable/notes/large_scale_deployments.html)
  * [LibTorch Stable ABI](https://docs.pytorch.org/docs/stable/notes/libtorch_stable_abi.html)
  * [Modules](https://docs.pytorch.org/docs/stable/notes/modules.html)
  * [MPS backend](https://docs.pytorch.org/docs/stable/notes/mps.html)
  * [Multiprocessing best practices](https://docs.pytorch.org/docs/stable/notes/multiprocessing.html)
  * [Numerical accuracy](https://docs.pytorch.org/docs/stable/notes/numerical_accuracy.html)
  * [Reproducibility](https://docs.pytorch.org/docs/stable/notes/randomness.html)
  * [Serialization semantics](https://docs.pytorch.org/docs/stable/notes/serialization.html)
  * [Windows FAQ](https://docs.pytorch.org/docs/stable/notes/windows.html)


Language Bindings[ - ][ + ]
  * [C++](https://docs.pytorch.org/docs/stable/cpp_index.html)
  * [Javadoc](https://pytorch.org/javadoc/)
  * [torch::deploy](https://docs.pytorch.org/docs/stable/deploy.html)


Python API[ - ][ + ]
  * [torch](https://docs.pytorch.org/docs/stable/torch.html)
  * [torch.nn](https://docs.pytorch.org/docs/stable/nn.html)
  * [torch.nn.functional](https://docs.pytorch.org/docs/stable/nn.functional.html)
  * [torch.Tensor](https://docs.pytorch.org/docs/stable/tensors.html)
  * [Tensor Attributes](https://docs.pytorch.org/docs/stable/tensor_attributes.html)
  * [Tensor Views](https://docs.pytorch.org/docs/stable/tensor_view.html)
  * [torch.amp](https://docs.pytorch.org/docs/stable/amp.html)
  * [torch.autograd](https://docs.pytorch.org/docs/stable/autograd.html)
  * [torch.library](https://docs.pytorch.org/docs/stable/library.html)
  * [torch.accelerator](https://docs.pytorch.org/docs/stable/accelerator.html)
  * [torch.cpu](https://docs.pytorch.org/docs/stable/cpu.html)
  * [torch.cuda](https://docs.pytorch.org/docs/stable/cuda.html)
  * [Understanding CUDA Memory Usage](https://docs.pytorch.org/docs/stable/torch_cuda_memory.html)
  * [Generating a Snapshot](https://docs.pytorch.org/docs/stable/torch_cuda_memory.html#generating-a-snapshot)
  * [Using the visualizer](https://docs.pytorch.org/docs/stable/torch_cuda_memory.html#using-the-visualizer)
  * [Snapshot API Reference](https://docs.pytorch.org/docs/stable/torch_cuda_memory.html#snapshot-api-reference)
  * [torch.mps](https://docs.pytorch.org/docs/stable/mps.html)
  * [torch.xpu](https://docs.pytorch.org/docs/stable/xpu.html)
  * [torch.mtia](https://docs.pytorch.org/docs/stable/mtia.html)
  * [torch.mtia.memory](https://docs.pytorch.org/docs/stable/mtia.memory.html)
  * [Meta device](https://docs.pytorch.org/docs/stable/meta.html)
  * [torch.backends](https://docs.pytorch.org/docs/stable/backends.html)
  * [torch.export](https://docs.pytorch.org/docs/stable/export.html)
  * [torch.distributed](https://docs.pytorch.org/docs/stable/distributed.html)
  * [torch.distributed.tensor](https://docs.pytorch.org/docs/stable/distributed.tensor.html)
  * [torch.distributed.algorithms.join](https://docs.pytorch.org/docs/stable/distributed.algorithms.join.html)
  * [torch.distributed.elastic](https://docs.pytorch.org/docs/stable/distributed.elastic.html)
  * [torch.distributed.fsdp](https://docs.pytorch.org/docs/stable/fsdp.html)
  * [torch.distributed.fsdp.fully_shard](https://docs.pytorch.org/docs/stable/distributed.fsdp.fully_shard.html)
  * [torch.distributed.tensor.parallel](https://docs.pytorch.org/docs/stable/distributed.tensor.parallel.html)
  * [torch.distributed.optim](https://docs.pytorch.org/docs/stable/distributed.optim.html)
  * [torch.distributed.pipelining](https://docs.pytorch.org/docs/stable/distributed.pipelining.html)
  * [torch.distributed.checkpoint](https://docs.pytorch.org/docs/stable/distributed.checkpoint.html)
  * [torch.distributions](https://docs.pytorch.org/docs/stable/distributions.html)
  * [torch.compiler](https://docs.pytorch.org/docs/stable/torch.compiler.html)
  * [torch.fft](https://docs.pytorch.org/docs/stable/fft.html)
  * [torch.func](https://docs.pytorch.org/docs/stable/func.html)
  * [torch.futures](https://docs.pytorch.org/docs/stable/futures.html)
  * [torch.fx](https://docs.pytorch.org/docs/stable/fx.html)
  * [torch.fx.experimental](https://docs.pytorch.org/docs/stable/fx.experimental.html)
  * [torch.hub](https://docs.pytorch.org/docs/stable/hub.html)
  * [torch.jit](https://docs.pytorch.org/docs/stable/jit.html)
  * [torch.linalg](https://docs.pytorch.org/docs/stable/linalg.html)
  * [torch.monitor](https://docs.pytorch.org/docs/stable/monitor.html)
  * [torch.signal](https://docs.pytorch.org/docs/stable/signal.html)
  * [torch.special](https://docs.pytorch.org/docs/stable/special.html)
  * [torch.overrides](https://docs.pytorch.org/docs/stable/torch.overrides.html)
  * [torch.package](https://docs.pytorch.org/docs/stable/package.html)
  * [torch.profiler](https://docs.pytorch.org/docs/stable/profiler.html)
  * [torch.nn.init](https://docs.pytorch.org/docs/stable/nn.init.html)
  * [torch.nn.attention](https://docs.pytorch.org/docs/stable/nn.attention.html)
  * [torch.onnx](https://docs.pytorch.org/docs/stable/onnx.html)
  * [torch.optim](https://docs.pytorch.org/docs/stable/optim.html)
  * [Complex Numbers](https://docs.pytorch.org/docs/stable/complex_numbers.html)
  * [DDP Communication Hooks](https://docs.pytorch.org/docs/stable/ddp_comm_hooks.html)
  * [Quantization](https://docs.pytorch.org/docs/stable/quantization.html)
  * [Distributed RPC Framework](https://docs.pytorch.org/docs/stable/rpc.html)
  * [torch.random](https://docs.pytorch.org/docs/stable/random.html)
  * [torch.masked](https://docs.pytorch.org/docs/stable/masked.html)
  * [torch.nested](https://docs.pytorch.org/docs/stable/nested.html)
  * [torch.Size](https://docs.pytorch.org/docs/stable/size.html)
  * [torch.sparse](https://docs.pytorch.org/docs/stable/sparse.html)
  * [torch.Storage](https://docs.pytorch.org/docs/stable/storage.html)
  * [torch.testing](https://docs.pytorch.org/docs/stable/testing.html)
  * [torch.utils](https://docs.pytorch.org/docs/stable/utils.html)
  * [torch.utils.benchmark](https://docs.pytorch.org/docs/stable/benchmark_utils.html)
  * [torch.utils.bottleneck](https://docs.pytorch.org/docs/stable/bottleneck.html)
  * [torch.utils.checkpoint](https://docs.pytorch.org/docs/stable/checkpoint.html)
  * [torch.utils.cpp_extension](https://docs.pytorch.org/docs/stable/cpp_extension.html)
  * [torch.utils.data](https://docs.pytorch.org/docs/stable/data.html)
  * [torch.utils.deterministic](https://docs.pytorch.org/docs/stable/deterministic.html)
  * [torch.utils.jit](https://docs.pytorch.org/docs/stable/jit_utils.html)
  * [torch.utils.dlpack](https://docs.pytorch.org/docs/stable/dlpack.html)
  * [torch.utils.mobile_optimizer](https://docs.pytorch.org/docs/stable/mobile_optimizer.html)
  * [torch.utils.model_zoo](https://docs.pytorch.org/docs/stable/model_zoo.html)
  * [torch.utils.tensorboard](https://docs.pytorch.org/docs/stable/tensorboard.html)
  * [torch.utils.module_tracker](https://docs.pytorch.org/docs/stable/module_tracker.html)
  * [Type Info](https://docs.pytorch.org/docs/stable/type_info.html)
  * [Named Tensors](https://docs.pytorch.org/docs/stable/named_tensor.html)
  * [Named Tensors operator coverage](https://docs.pytorch.org/docs/stable/name_inference.html)
  * [torch.__config__](https://docs.pytorch.org/docs/stable/config_mod.html)
  * [torch.__future__](https://docs.pytorch.org/docs/stable/future_mod.html)
  * [torch._logging](https://docs.pytorch.org/docs/stable/logging.html)
  * [Torch Environment Variables](https://docs.pytorch.org/docs/stable/torch_environment_variables.html)


Libraries[ - ][ + ]
  * [torchaudio](https://pytorch.org/audio/stable)
  * [TorchData](https://pytorch.org/data)
  * [TorchRec](https://pytorch.org/torchrec)
  * [TorchServe](https://pytorch.org/serve)
  * [torchtext](https://pytorch.org/text/stable)
  * [torchvision](https://pytorch.org/vision/stable)
  * [PyTorch on XLA Devices](https://pytorch.org/xla/)
  * [torchao](https://pytorch.org/ao)


  * [ Docs ](https://docs.pytorch.org/docs/stable/index.html) >
  * torch.library
  * [![](https://docs.pytorch.org/docs/stable/_static/images/view-page-source-icon.svg)](https://docs.pytorch.org/docs/stable/_sources/library.rst.txt)


Shortcuts 
# torch.library[](https://docs.pytorch.org/docs/stable/library.html#module-torch.library)
torch.library is a collection of APIs for extending PyTorch’s core library of operators. It contains utilities for testing custom operators, creating new custom operators, and extending operators defined with PyTorch’s C++ operator registration APIs (e.g. aten operators).
For a detailed guide on effectively using these APIs, please see [PyTorch Custom Operators Landing Page](https://pytorch.org/tutorials/advanced/custom_ops_landing_page.html) for more details on how to effectively use these APIs.
## Testing custom ops[](https://docs.pytorch.org/docs/stable/library.html#testing-custom-ops)
Use [`torch.library.opcheck()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.opcheck "torch.library.opcheck") to test custom ops for incorrect usage of the Python torch.library and/or C++ TORCH_LIBRARY APIs. Also, if your operator supports training, use [`torch.autograd.gradcheck()`](https://docs.pytorch.org/docs/stable/autograd.html#module-torch.autograd.gradcheck "torch.autograd.gradcheck") to test that the gradients are mathematically correct. 

torch.library.opcheck(_op_ , _args_ , _kwargs =None_, _*_ , _test_utils =('test_schema', 'test_autograd_registration', 'test_faketensor', 'test_aot_dispatch_dynamic')_, _raise_exception =True_, _atol =None_, _rtol =None_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#opcheck)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L1445)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.opcheck) 
    
Given an operator and some sample arguments, tests if the operator is registered correctly.
That is, when you use the torch.library/TORCH_LIBRARY APIs to create a custom op, you specified metadata (e.g. mutability info) about the custom op and these APIs require that the functions you pass them satisfy certain properties (e.g. no data pointer access in the fake/meta/abstract kernel) `opcheck` tests these metadata and properties.
Concretely, we test the following:
  * test_schema: If the schema matches the implementation of the operator. For example: if the schema specifies a Tensor is mutated, then we check the implementation mutates the Tensor. If the schema specifies that we return a new Tensor, then we check that the implementation returns a new Tensor (instead of an existing one or a view of an existing one).
  * test_autograd_registration: If the operator supports training (autograd): we check that its autograd formula is registered via torch.library.register_autograd or a manual registration to one or more DispatchKey::Autograd keys. Any other DispatchKey-based registrations may lead to undefined behavior.
  * test_faketensor: If the operator has a FakeTensor kernel (and if it is correct). The FakeTensor kernel is necessary ( but not sufficient) for the operator to work with PyTorch compilation APIs (torch.compile/export/FX). We check that a FakeTensor kernel (also sometimes known as a meta kernel) was registered for the operator and that it is correct. This test takes the result of running the operator on real tensors and the result of running the operator on FakeTensors and checks that they have the same Tensor metadata (sizes/strides/dtype/device/etc).
  * test_aot_dispatch_dynamic: If the operator has correct behavior with PyTorch compilation APIs (torch.compile/export/FX). This checks that the outputs (and gradients, if applicable) are the same under eager-mode PyTorch and torch.compile. This test is a superset of `test_faketensor` and is an e2e test; other things it tests are that the operator supports functionalization and that the backward pass (if it exists) also supports FakeTensor and functionalization.


For best results, please call `opcheck` multiple times with a representative set of inputs. If your operator supports autograd, please use `opcheck` with inputs with `requires_grad = True`; if your operator supports multiple devices (e.g. CPU and CUDA), please use `opcheck` with inputs on all supported devices. 

Parameters
    
  * **op** ([_Union_](https://docs.python.org/3/library/typing.html#typing.Union "\(in Python v3.13\)") _[__OpOverload_ _,__OpOverloadPacket_ _,_[_CustomOpDef_](https://docs.pytorch.org/docs/stable/library.html#torch._library.custom_ops.CustomOpDef "torch._library.custom_ops.CustomOpDef") _]_) – The operator. Must either be a function decorated with [`torch.library.custom_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.custom_op "torch.library.custom_op") or an OpOverload/OpOverloadPacket found in torch.ops.* (e.g. torch.ops.aten.sin, torch.ops.mylib.foo)
  * **args** ([_tuple_](https://docs.python.org/3/library/stdtypes.html#tuple "\(in Python v3.13\)") _[_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _,__...__]_) – The args to the operator
  * **kwargs** ([_Optional_](https://docs.python.org/3/library/typing.html#typing.Optional "\(in Python v3.13\)") _[_[_dict_](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)") _]__]_) – The kwargs to the operator
  * **test_utils** ([_Union_](https://docs.python.org/3/library/typing.html#typing.Union "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _,_[_Sequence_](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "\(in Python v3.13\)") _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]__]_) – Tests that we should run. Default: all of them. Example: (“test_schema”, “test_faketensor”)
  * **raise_exception** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – If we should raise an exception on the first error. If False, we will return a dict with information on if each test passed or not.
  * **rtol** (_Optional_ _[_[_float_](https://docs.python.org/3/library/functions.html#float "\(in Python v3.13\)") _]_) – Relative tolerance for floating point comparisons. If specified `atol` must also be specified. If omitted, default values based on the `dtype` are selected (see the table in [`torch.testing.assert_close()`](https://docs.pytorch.org/docs/stable/testing.html#torch.testing.assert_close "torch.testing.assert_close")).
  * **atol** (_Optional_ _[_[_float_](https://docs.python.org/3/library/functions.html#float "\(in Python v3.13\)") _]_) – Absolute tolerance for floating point comparisons. If specified `rtol` must also be specified. If omitted, default values based on the `dtype` are selected (see the table in [`torch.testing.assert_close()`](https://docs.pytorch.org/docs/stable/testing.html#torch.testing.assert_close "torch.testing.assert_close")).



Return type
    
[dict](https://docs.python.org/3/library/stdtypes.html#dict "\(in Python v3.13\)")[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"), [str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]
Warning
opcheck and [`torch.autograd.gradcheck()`](https://docs.pytorch.org/docs/stable/autograd.html#module-torch.autograd.gradcheck "torch.autograd.gradcheck") test different things; opcheck tests if your usage of torch.library APIs is correct while [`torch.autograd.gradcheck()`](https://docs.pytorch.org/docs/stable/autograd.html#module-torch.autograd.gradcheck "torch.autograd.gradcheck") tests if your autograd formula is mathematically correct. Use both to test custom ops that support gradient computation.
Example
```
>>> @torch.library.custom_op("mylib::numpy_mul", mutates_args=())
>>> def numpy_mul(x: Tensor, y: float) -> Tensor:
>>>     x_np = x.numpy(force=True)
>>>     z_np = x_np * y
>>>     return torch.from_numpy(z_np).to(x.device)
>>>
>>> @numpy_mul.register_fake
>>> def _(x, y):
>>>     return torch.empty_like(x)
>>>
>>> def setup_context(ctx, inputs, output):
>>>     y, = inputs
>>>     ctx.y = y
>>>
>>> def backward(ctx, grad):
>>>     return grad * ctx.y, None
>>>
>>> numpy_mul.register_autograd(backward, setup_context=setup_context)
>>>
>>> sample_inputs = [
>>>     (torch.randn(3), 3.14),
>>>     (torch.randn(2, 3, device='cuda'), 2.718),
>>>     (torch.randn(1, 10, requires_grad=True), 1.234),
>>>     (torch.randn(64, 64, device='cuda', requires_grad=True), 90.18),
>>> ]
>>>
>>> for args in sample_inputs:
>>>     torch.library.opcheck(numpy_mul, args)

```
Copy to clipboard
## Creating new custom ops in Python[](https://docs.pytorch.org/docs/stable/library.html#creating-new-custom-ops-in-python)
Use [`torch.library.custom_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.custom_op "torch.library.custom_op") to create new custom ops. 

torch.library.custom_op(_name_ , _fn =None_, _/_ , _*_ , _mutates_args_ , _device_types =None_, _schema =None_)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/_library/custom_ops.py#L48)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.custom_op) 
    
Wraps a function into custom operator.
Reasons why you may want to create a custom op include: - Wrapping a third-party library or custom kernel to work with PyTorch subsystems like Autograd. - Preventing torch.compile/export/FX tracing from peeking inside your function.
This API is used as a decorator around a function (please see examples). The provided function must have type hints; these are needed to interface with PyTorch’s various subsystems. 

Parameters
    
  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A name for the custom op that looks like “{namespace}::{name}”, e.g. “mylib::my_linear”. The name is used as the op’s stable identifier in PyTorch subsystems (e.g. torch.export, FX graphs). To avoid name collisions, please use your project name as the namespace; e.g. all custom ops in pytorch/fbgemm use “fbgemm” as the namespace.
  * **mutates_args** (_Iterable_ _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _] or_ _"unknown"_) – The names of args that the function mutates. This MUST be accurate, otherwise, the behavior is undefined. If “unknown”, it pessimistically assumes that all inputs to the operator are being mutated.
  * **device_types** (_None_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__Sequence_ _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]_) – The device type(s) the function is valid for. If no device type is provided, then the function is used as the default implementation for all device types. Examples: “cpu”, “cuda”. When registering a device-specific implementation for an operator that accepts no Tensors, we require the operator to have a “device: torch.device argument”.
  * **schema** (_None_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A schema string for the operator. If None (recommended) we’ll infer a schema for the operator from its type annotations. We recommend letting us infer a schema unless you have a specific reason not to. Example: “(Tensor x, int y) -> (Tensor, Tensor)”.



Return type
    
[_Union_](https://docs.python.org/3/library/typing.html#typing.Union "\(in Python v3.13\)")[[_Callable_](https://docs.python.org/3/library/typing.html#typing.Callable "\(in Python v3.13\)")[[[_Callable_](https://docs.python.org/3/library/typing.html#typing.Callable "\(in Python v3.13\)")[[…], [object](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")]], [_CustomOpDef_](https://docs.pytorch.org/docs/stable/library.html#torch._library.custom_ops.CustomOpDef "torch._library.custom_ops.CustomOpDef")], [_CustomOpDef_](https://docs.pytorch.org/docs/stable/library.html#torch._library.custom_ops.CustomOpDef "torch._library.custom_ops.CustomOpDef")]
Note
We recommend not passing in a `schema` arg and instead letting us infer it from the type annotations. It is error-prone to write your own schema. You may wish to provide your own schema if our interpretation of the type annotation is not what you want. For more info on how to write a schema string, see [here](https://github.com/pytorch/pytorch/blob/main/aten/src/ATen/native/README.md#func) 

Examples::
    
```
>>> import torch
>>> from torch import Tensor
>>> from torch.library import custom_op
>>> import numpy as np
>>>
>>> @custom_op("mylib::numpy_sin", mutates_args=())
>>> def numpy_sin(x: Tensor) -> Tensor:
>>>     x_np = x.cpu().numpy()
>>>     y_np = np.sin(x_np)
>>>     return torch.from_numpy(y_np).to(device=x.device)
>>>
>>> x = torch.randn(3)
>>> y = numpy_sin(x)
>>> assert torch.allclose(y, x.sin())
>>>
>>> # Example of a custom op that only works for one device type.
>>> @custom_op("mylib::numpy_sin_cpu", mutates_args=(), device_types="cpu")
>>> def numpy_sin_cpu(x: Tensor) -> Tensor:
>>>     x_np = x.numpy()
>>>     y_np = np.sin(x_np)
>>>     return torch.from_numpy(y_np)
>>>
>>> x = torch.randn(3)
>>> y = numpy_sin_cpu(x)
>>> assert torch.allclose(y, x.sin())
>>>
>>> # Example of a custom op that mutates an input
>>> @custom_op("mylib::numpy_sin_inplace", mutates_args={"x"}, device_types="cpu")
>>> def numpy_sin_inplace(x: Tensor) -> None:
>>>     x_np = x.numpy()
>>>     np.sin(x_np, out=x_np)
>>>
>>> x = torch.randn(3)
>>> expected = x.sin()
>>> numpy_sin_inplace(x)
>>> assert torch.allclose(x, expected)
>>>
>>> # Example of a factory function
>>> @torch.library.custom_op("mylib::bar", mutates_args={}, device_types="cpu")
>>> def bar(device: torch.device) -> Tensor:
>>>     return torch.ones(3)
>>>
>>> bar("cpu")

```
Copy to clipboard 

torch.library.triton_op(_name_ , _fn =None_, _/_ , _*_ , _mutates_args_ , _schema =None_)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/_library/triton.py#L12)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.triton_op) 
    
Create a custom operator whose implementation is backed by 1+ triton kernels.
This is a more structured way of using triton kernels with PyTorch. Prefer using triton kernels with no `torch.library` custom operator wrappers (like [`torch.library.custom_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.custom_op "torch.library.custom_op"), [`torch.library.triton_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.triton_op "torch.library.triton_op")) because that is simpler; only use [`torch.library.custom_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.custom_op "torch.library.custom_op")/[`torch.library.triton_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.triton_op "torch.library.triton_op") if you want to create an operator that behaves like PyTorch built-in operators. For example, you may use a `torch.library` wrapper API to define the behavior of the triton kernel when passed a tensor subclass or under a TorchDispatchMode.
Use [`torch.library.triton_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.triton_op "torch.library.triton_op") instead of [`torch.library.custom_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.custom_op "torch.library.custom_op") when the implementation consists of 1+ triton kernels. [`torch.library.custom_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.custom_op "torch.library.custom_op") treats custom operators as opaque ([`torch.compile()`](https://docs.pytorch.org/docs/stable/generated/torch.compile.html#torch.compile "torch.compile") and [`torch.export.export()`](https://docs.pytorch.org/docs/stable/export.html#torch.export.export "torch.export.export") will never trace into them), but `triton_op` makes the implementation visible to these subsystems, allowing them to optimize the triton kernel(s).
Note that `fn` must only consist of calls to PyTorch-understood operators and triton kernels. Any triton kernels called inside `fn` must be wrapped in a call to [`torch.library.wrap_triton()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.wrap_triton "torch.library.wrap_triton"). 

Parameters
    
  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A name for the custom op that looks like “{namespace}::{name}”, e.g. “mylib::my_linear”. The name is used as the op’s stable identifier in PyTorch subsystems (e.g. torch.export, FX graphs). To avoid name collisions, please use your project name as the namespace; e.g. all custom ops in pytorch/fbgemm use “fbgemm” as the namespace.
  * **mutates_args** (_Iterable_ _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _] or_ _"unknown"_) – The names of args that the function mutates. This MUST be accurate, otherwise, the behavior is undefined. If “unknown”, it pessimistically assumes that all inputs to the operator are being mutated.
  * **schema** (_None_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – A schema string for the operator. If None (recommended) we’ll infer a schema for the operator from its type annotations. We recommend letting us infer a schema unless you have a specific reason not to. Example: “(Tensor x, int y) -> (Tensor, Tensor)”.



Return type
    
[_Callable_](https://docs.python.org/3/library/typing.html#typing.Callable "\(in Python v3.13\)")
Example:
```
>>> import torch
>>> from torch.library import triton_op, wrap_triton
>>>
>>> import triton
>>> from triton import language as tl
>>>
>>> @triton.jit
>>> def add_kernel(
>>>     in_ptr0,
>>>     in_ptr1,
>>>     out_ptr,
>>>     n_elements,
>>>     BLOCK_SIZE: "tl.constexpr",
>>> ):
>>>     pid = tl.program_id(axis=0)
>>>     block_start = pid * BLOCK_SIZE
>>>     offsets = block_start + tl.arange(0, BLOCK_SIZE)
>>>     mask = offsets < n_elements
>>>     x = tl.load(in_ptr0 + offsets, mask=mask)
>>>     y = tl.load(in_ptr1 + offsets, mask=mask)
>>>     output = x + y
>>>     tl.store(out_ptr + offsets, output, mask=mask)
>>>
>>> @triton_op("mylib::add", mutates_args={})
>>> def add(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor:
>>>     output = torch.empty_like(x)
>>>     n_elements = output.numel()
>>>
>>>     def grid(meta):
>>>         return (triton.cdiv(n_elements, meta["BLOCK_SIZE"]),)
>>>
>>>     # NB: we need to wrap the triton kernel in a call to wrap_triton
>>>     wrap_triton(add_kernel)[grid](x, y, output, n_elements, 16)
>>>     return output
>>>
>>> @torch.compile
>>> def f(x, y):
>>>     return add(x, y)
>>>
>>> x = torch.randn(3, device="cuda")
>>> y = torch.randn(3, device="cuda")
>>>
>>> z = f(x, y)
>>> assert torch.allclose(z, x + y)

```
Copy to clipboard 

torch.library.wrap_triton(_triton_kernel_ , _/_)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/_library/triton.py#L200)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.wrap_triton) 
    
Allows capture of a triton kernel into a graph via make_fx or non-strict `torch.export`.
These technologies perform Dispatcher-based tracing (via `__torch_dispatch__`) and cannot see calls to raw triton kernels. The `wrap_triton` API wraps a triton kernel into a callable that can actually be traced into a graph.
Please use this API together with [`torch.library.triton_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.triton_op "torch.library.triton_op").
Examples
```
>>> import torch
>>> import triton
>>> from triton import language as tl
>>> from torch.fx.experimental.proxy_tensor import make_fx
>>> from torch.library import wrap_triton
>>>
>>> @triton.jit
>>> def add_kernel(
>>>     in_ptr0,
>>>     in_ptr1,
>>>     out_ptr,
>>>     n_elements,
>>>     BLOCK_SIZE: "tl.constexpr",
>>> ):
>>>     pid = tl.program_id(axis=0)
>>>     block_start = pid * BLOCK_SIZE
>>>     offsets = block_start + tl.arange(0, BLOCK_SIZE)
>>>     mask = offsets < n_elements
>>>     x = tl.load(in_ptr0 + offsets, mask=mask)
>>>     y = tl.load(in_ptr1 + offsets, mask=mask)
>>>     output = x + y
>>>     tl.store(out_ptr + offsets, output, mask=mask)
>>>
>>> def add(x, y):
>>>     output = torch.empty_like(x)
>>>     n_elements = output.numel()
>>>
>>>     def grid_fn(meta):
>>>         return (triton.cdiv(n_elements, meta["BLOCK_SIZE"]),)
>>>
>>>     wrap_triton(add_kernel)[grid_fn](x, y, output, n_elements, 16)
>>>     return output
>>>
>>> x = torch.randn(3, device="cuda")
>>> y = torch.randn(3, device="cuda")
>>> gm = make_fx(add)(x, y)
>>> print(gm.code)
>>> # def forward(self, x_1, y_1):
>>> #     empty_like = torch.ops.aten.empty_like.default(x_1, pin_memory = False)
>>> #     triton_kernel_wrapper_mutation_proxy = triton_kernel_wrapper_mutation(
>>> #         kernel_idx = 0, constant_args_idx = 0,
>>> #         grid = [(1, 1, 1)], kwargs = {
>>> #             'in_ptr0': x_1, 'in_ptr1': y_1, 'out_ptr': empty_like,
>>> #             'n_elements': 3, 'BLOCK_SIZE': 16
>>> #         })
>>> #     return empty_like

```
Copy to clipboard 

Return type
    
[_Any_](https://docs.python.org/3/library/typing.html#typing.Any "\(in Python v3.13\)")
## Extending custom ops (created from Python or C++)[](https://docs.pytorch.org/docs/stable/library.html#extending-custom-ops-created-from-python-or-c)
Use the register.* methods, such as [`torch.library.register_kernel()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_kernel "torch.library.register_kernel") and [`torch.library.register_fake()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_fake "torch.library.register_fake"), to add implementations for any operators (they may have been created using [`torch.library.custom_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.custom_op "torch.library.custom_op") or via PyTorch’s C++ operator registration APIs). 

torch.library.register_kernel(_op_ , _device_types_ , _func =None_, _/_ , _*_ , _lib =None_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#register_kernel)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L763)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_kernel) 
    
Register an implementation for a device type for this operator.
Some valid device_types are: “cpu”, “cuda”, “xla”, “mps”, “ipu”, “xpu”. This API may be used as a decorator. 

Parameters
    
  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__OpOverload_) – The operator to register an impl to.
  * **device_types** (_None_ _|_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__Sequence_ _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]_) – The device_types to register an impl to. If None, we will register to all device types – please only use this option if your implementation is truly device-type-agnostic.
  * **func** (_Callable_) – The function to register as the implementation for the given device types.
  * **lib** (_Optional_ _[_[_Library_](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library "torch.library.Library") _]_) – If provided, the lifetime of this registration



Examples::
    
```
>>> import torch
>>> from torch import Tensor
>>> from torch.library import custom_op
>>> import numpy as np
>>>
>>> # Create a custom op that works on cpu
>>> @custom_op("mylib::numpy_sin", mutates_args=(), device_types="cpu")
>>> def numpy_sin(x: Tensor) -> Tensor:
>>>     x_np = x.numpy()
>>>     y_np = np.sin(x_np)
>>>     return torch.from_numpy(y_np)
>>>
>>> # Add implementations for the cuda device
>>> @torch.library.register_kernel("mylib::numpy_sin", "cuda")
>>> def _(x):
>>>     x_np = x.cpu().numpy()
>>>     y_np = np.sin(x_np)
>>>     return torch.from_numpy(y_np).to(device=x.device)
>>>
>>> x_cpu = torch.randn(3)
>>> x_cuda = x_cpu.cuda()
>>> assert torch.allclose(numpy_sin(x_cpu), x_cpu.sin())
>>> assert torch.allclose(numpy_sin(x_cuda), x_cuda.sin())

```
Copy to clipboard 

torch.library.register_autocast(_op_ , _device_type_ , _cast_inputs_ , _/_ , _*_ , _lib =None_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#register_autocast)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L831)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_autocast) 
    
Register an autocast dispatch rule for this custom op.
Valid device_type include: “cpu” and “cuda”. 

Parameters
    
  * **op** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__OpOverload_) – The operator to register an autocast dispatch rule to.
  * **device_type** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Device type to use. ‘cuda’ or ‘cpu’. The type is the same as the type attribute of a [`torch.device`](https://docs.pytorch.org/docs/stable/tensor_attributes.html#torch.device "torch.device"). Thus, you may obtain the device type of a tensor using Tensor.device.type.
  * **cast_inputs** ([`torch.dtype`](https://docs.pytorch.org/docs/stable/tensor_attributes.html#torch.dtype "torch.dtype")) – When custom op runs in an autocast-enabled region, casts incoming floating-point Tensors to the target dtype (non-floating-point Tensors are not affected), then executes custom op with autocast disabled.
  * **lib** (_Optional_ _[_[_Library_](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library "torch.library.Library") _]_) – If provided, the lifetime of this registration



Examples::
    
```
>>> import torch
>>> from torch import Tensor
>>> from torch.library import custom_op
>>>
>>> # Create a custom op that works on cuda
>>> @torch.library.custom_op("mylib::my_sin", mutates_args=())
>>> def my_sin(x: Tensor) -> Tensor:
>>>     return torch.sin(x)
>>>
>>> # Register autocast dispatch rule for the cuda device
>>> torch.library.register_autocast("mylib::my_sin", "cuda", torch.float16)
>>>
>>> x = torch.randn(3, dtype=torch.float32, device="cuda")
>>> with torch.autocast("cuda", dtype=torch.float16):
>>>     y = torch.ops.mylib.my_sin(x)
>>> assert y.dtype == torch.float16

```
Copy to clipboard 

torch.library.register_autograd(_op_ , _backward_ , _/_ , _*_ , _setup_context =None_, _lib =None_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#register_autograd)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L1033)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_autograd) 
    
Register a backward formula for this custom op.
In order for an operator to work with autograd, you need to register a backward formula: 1. You must tell us how to compute gradients during the backward pass by providing us a “backward” function. 2. If you need any values from the forward to compute gradients, you can use setup_context to save values for backward.
`backward` runs during the backward pass. It accepts `(ctx, *grads)`: - `grads` is one or more gradients. The number of gradients matches the number of outputs of the operator. The `ctx` object is [the same ctx object](https://docs.pytorch.org/docs/stable/context_method_mixins) used by [`torch.autograd.Function`](https://docs.pytorch.org/docs/stable/autograd.html#torch.autograd.Function "torch.autograd.Function"). The semantics of `backward_fn` are the same as [`torch.autograd.Function.backward()`](https://docs.pytorch.org/docs/stable/generated/torch.autograd.Function.backward.html#torch.autograd.Function.backward "torch.autograd.Function.backward").
`setup_context(ctx, inputs, output)` runs during the forward pass. Please save quantities needed for backward onto the `ctx` object via either [`torch.autograd.function.FunctionCtx.save_for_backward()`](https://docs.pytorch.org/docs/stable/generated/torch.autograd.function.FunctionCtx.save_for_backward.html#torch.autograd.function.FunctionCtx.save_for_backward "torch.autograd.function.FunctionCtx.save_for_backward") or assigning them as attributes of `ctx`. If your custom op has kwarg-only arguments, we expect the signature of `setup_context` to be `setup_context(ctx, inputs, keyword_only_inputs, output)`.
Both `setup_context_fn` and `backward_fn` must be traceable. That is, they may not directly access [`torch.Tensor.data_ptr()`](https://docs.pytorch.org/docs/stable/generated/torch.Tensor.data_ptr.html#torch.Tensor.data_ptr "torch.Tensor.data_ptr") and they must not depend on or mutate global state. If you need a non-traceable backward, you can make it a separate custom_op that you call inside `backward_fn`.
If you need different autograd behavior on different devices, then we recommend creating two different custom operators, one for each device that needs different behavior, and switching between them at runtime.
Examples
```
>>> import torch
>>> import numpy as np
>>> from torch import Tensor
>>>
>>> @torch.library.custom_op("mylib::numpy_sin", mutates_args=())
>>> def numpy_sin(x: Tensor) -> Tensor:
>>>     x_np = x.cpu().numpy()
>>>     y_np = np.sin(x_np)
>>>     return torch.from_numpy(y_np).to(device=x.device)
>>>
>>> def setup_context(ctx, inputs, output) -> Tensor:
>>>     x, = inputs
>>>     ctx.save_for_backward(x)
>>>
>>> def backward(ctx, grad):
>>>     x, = ctx.saved_tensors
>>>     return grad * x.cos()
>>>
>>> torch.library.register_autograd(
...     "mylib::numpy_sin", backward, setup_context=setup_context
... )
>>>
>>> x = torch.randn(3, requires_grad=True)
>>> y = numpy_sin(x)
>>> (grad_x,) = torch.autograd.grad(y, x, torch.ones_like(y))
>>> assert torch.allclose(grad_x, x.cos())
>>>
>>> # Example with a keyword-only arg
>>> @torch.library.custom_op("mylib::numpy_mul", mutates_args=())
>>> def numpy_mul(x: Tensor, *, val: float) -> Tensor:
>>>     x_np = x.cpu().numpy()
>>>     y_np = x_np * val
>>>     return torch.from_numpy(y_np).to(device=x.device)
>>>
>>> def setup_context(ctx, inputs, keyword_only_inputs, output) -> Tensor:
>>>     ctx.val = keyword_only_inputs["val"]
>>>
>>> def backward(ctx, grad):
>>>     return grad * ctx.val
>>>
>>> torch.library.register_autograd(
...     "mylib::numpy_mul", backward, setup_context=setup_context
... )
>>>
>>> x = torch.randn(3, requires_grad=True)
>>> y = numpy_mul(x, val=3.14)
>>> (grad_x,) = torch.autograd.grad(y, x, torch.ones_like(y))
>>> assert torch.allclose(grad_x, torch.full_like(x, 3.14))

```
Copy to clipboard 

torch.library.register_fake(_op_ , _func =None_, _/_ , _*_ , _lib =None_, __stacklevel =1_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#register_fake)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L912)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_fake) 
    
Register a FakeTensor implementation (“fake impl”) for this operator.
Also sometimes known as a “meta kernel”, “abstract impl”.
An “FakeTensor implementation” specifies the behavior of this operator on Tensors that carry no data (“FakeTensor”). Given some input Tensors with certain properties (sizes/strides/storage_offset/device), it specifies what the properties of the output Tensors are.
The FakeTensor implementation has the same signature as the operator. It is run for both FakeTensors and meta tensors. To write a FakeTensor implementation, assume that all Tensor inputs to the operator are regular CPU/CUDA/Meta tensors, but they do not have storage, and you are trying to return regular CPU/CUDA/Meta tensor(s) as output. The FakeTensor implementation must consist of only PyTorch operations (and may not directly access the storage or data of any input or intermediate Tensors).
This API may be used as a decorator (see examples).
For a detailed guide on custom ops, please see <https://pytorch.org/tutorials/advanced/custom_ops_landing_page.html>
Examples
```
>>> import torch
>>> import numpy as np
>>> from torch import Tensor
>>>
>>> # Example 1: an operator without data-dependent output shape
>>> @torch.library.custom_op("mylib::custom_linear", mutates_args=())
>>> def custom_linear(x: Tensor, weight: Tensor, bias: Tensor) -> Tensor:
>>>     raise NotImplementedError("Implementation goes here")
>>>
>>> @torch.library.register_fake("mylib::custom_linear")
>>> def _(x, weight, bias):
>>>     assert x.dim() == 2
>>>     assert weight.dim() == 2
>>>     assert bias.dim() == 1
>>>     assert x.shape[1] == weight.shape[1]
>>>     assert weight.shape[0] == bias.shape[0]
>>>     assert x.device == weight.device
>>>
>>>     return (x @ weight.t()) + bias
>>>
>>> with torch._subclasses.fake_tensor.FakeTensorMode():
>>>     x = torch.randn(2, 3)
>>>     w = torch.randn(3, 3)
>>>     b = torch.randn(3)
>>>     y = torch.ops.mylib.custom_linear(x, w, b)
>>>
>>> assert y.shape == (2, 3)
>>>
>>> # Example 2: an operator with data-dependent output shape
>>> @torch.library.custom_op("mylib::custom_nonzero", mutates_args=())
>>> def custom_nonzero(x: Tensor) -> Tensor:
>>>     x_np = x.numpy(force=True)
>>>     res = np.stack(np.nonzero(x_np), axis=1)
>>>     return torch.tensor(res, device=x.device)
>>>
>>> @torch.library.register_fake("mylib::custom_nonzero")
>>> def _(x):
>>> # Number of nonzero-elements is data-dependent.
>>> # Since we cannot peek at the data in an fake impl,
>>> # we use the ctx object to construct a new symint that
>>> # represents the data-dependent size.
>>>     ctx = torch.library.get_ctx()
>>>     nnz = ctx.new_dynamic_size()
>>>     shape = [nnz, x.dim()]
>>>     result = x.new_empty(shape, dtype=torch.int64)
>>>     return result
>>>
>>> from torch.fx.experimental.proxy_tensor import make_fx
>>>
>>> x = torch.tensor([0, 1, 2, 3, 4, 0])
>>> trace = make_fx(torch.ops.mylib.custom_nonzero, tracing_mode="symbolic")(x)
>>> trace.print_readable()
>>>
>>> assert torch.allclose(trace(x), torch.ops.mylib.custom_nonzero(x))

```
Copy to clipboard 

torch.library.register_vmap(_op_ , _func =None_, _/_ , _*_ , _lib =None_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#register_vmap)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L1244)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_vmap) 
    
Register a vmap implementation to support [`torch.vmap()`](https://docs.pytorch.org/docs/stable/generated/torch.vmap.html#torch.vmap "torch.vmap") for this custom op.
This API may be used as a decorator (see examples).
In order for an operator to work with [`torch.vmap()`](https://docs.pytorch.org/docs/stable/generated/torch.vmap.html#torch.vmap "torch.vmap"), you may need to register a vmap implementation in the following signature:
> `vmap_func(info, in_dims: Tuple[Optional[int]], *args, **kwargs)`,
where `*args` and `**kwargs` are the arguments and kwargs for `op`. We do not support kwarg-only Tensor args.
It specifies how do we compute the batched version of `op` given inputs with an additional dimension (specified by `in_dims`).
For each arg in `args`, `in_dims` has a corresponding `Optional[int]`. It is `None` if the arg is not a Tensor or if the arg is not being vmapped over, otherwise, it is an integer specifying what dimension of the Tensor is being vmapped over.
`info` is a collection of additional metadata that may be helpful: `info.batch_size` specifies the size of the dimension being vmapped over, while `info.randomness` is the `randomness` option that was passed to [`torch.vmap()`](https://docs.pytorch.org/docs/stable/generated/torch.vmap.html#torch.vmap "torch.vmap").
The return of the function `func` is a tuple of `(output, out_dims)`. Similar to `in_dims`, `out_dims` should be of the same structure as `output` and contain one `out_dim` per output that specifies if the output has the vmapped dimension and what index it is in.
Examples
```
>>> import torch
>>> import numpy as np
>>> from torch import Tensor
>>> from typing import Tuple
>>>
>>> def to_numpy(tensor):
>>>     return tensor.cpu().numpy()
>>>
>>> lib = torch.library.Library("mylib", "FRAGMENT")
>>> @torch.library.custom_op("mylib::numpy_cube", mutates_args=())
>>> def numpy_cube(x: Tensor) -> Tuple[Tensor, Tensor]:
>>>     x_np = to_numpy(x)
>>>     dx = torch.tensor(3 * x_np ** 2, device=x.device)
>>>     return torch.tensor(x_np ** 3, device=x.device), dx
>>>
>>> def numpy_cube_vmap(info, in_dims, x):
>>>     result = numpy_cube(x)
>>>     return result, (in_dims[0], in_dims[0])
>>>
>>> torch.library.register_vmap(numpy_cube, numpy_cube_vmap)
>>>
>>> x = torch.randn(3)
>>> torch.vmap(numpy_cube)(x)
>>>
>>> @torch.library.custom_op("mylib::numpy_mul", mutates_args=())
>>> def numpy_mul(x: Tensor, y: Tensor) -> Tensor:
>>>     return torch.tensor(to_numpy(x) * to_numpy(y), device=x.device)
>>>
>>> @torch.library.register_vmap("mylib::numpy_mul")
>>> def numpy_mul_vmap(info, in_dims, x, y):
>>>     x_bdim, y_bdim = in_dims
>>>     x = x.movedim(x_bdim, -1) if x_bdim is not None else x.unsqueeze(-1)
>>>     y = y.movedim(y_bdim, -1) if y_bdim is not None else y.unsqueeze(-1)
>>>     result = x * y
>>>     result = result.movedim(-1, 0)
>>>     return result, 0
>>>
>>>
>>> x = torch.randn(3)
>>> y = torch.randn(3)
>>> torch.vmap(numpy_mul)(x, y)

```
Copy to clipboard
Note
The vmap function should aim to preserve the semantics of the entire custom operator. That is, `grad(vmap(op))` should be replaceable with a `grad(map(op))`.
If your custom operator has any custom behavior in the backward pass, please keep this in mind. 

torch.library.impl_abstract(_qualname_ , _func =None_, _*_ , _lib =None_, __stacklevel =1_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#impl_abstract)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L744)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.impl_abstract) 
    
This API was renamed to [`torch.library.register_fake()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_fake "torch.library.register_fake") in PyTorch 2.4. Please use that instead. 

torch.library.get_ctx()[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#get_ctx)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L1428)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.get_ctx) 
    
get_ctx() returns the current AbstractImplCtx object.
Calling `get_ctx()` is only valid inside of an fake impl (see [`torch.library.register_fake()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_fake "torch.library.register_fake") for more usage details. 

Return type
    
_FakeImplCtx_ 

torch.library.register_torch_dispatch(_op_ , _torch_dispatch_class_ , _func =None_, _/_ , _*_ , _lib =None_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#register_torch_dispatch)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L1163)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_torch_dispatch) 
    
Registers a torch_dispatch rule for the given operator and `torch_dispatch_class`.
This allows for open registration to specify the behavior between the operator and the `torch_dispatch_class` without needing to modify the `torch_dispatch_class` or the operator directly.
The `torch_dispatch_class` is either a Tensor subclass with `__torch_dispatch__` or a TorchDispatchMode.
If it is a Tensor subclass, we expect `func` to have the following signature: `(cls, func: OpOverload, types: Tuple[type, ...], args, kwargs) -> Any`
If it is a TorchDispatchMode, we expect `func` to have the following signature: `(mode, func: OpOverload, types: Tuple[type, ...], args, kwargs) -> Any`
`args` and `kwargs` will have been normalized the same way they are in `__torch_dispatch__` (see [__torch_dispatch__ calling convention](https://docs.pytorch.org/docs/stable/notes/extending.html#torch-dispatch-calling-convention)).
Examples
```
>>> import torch
>>>
>>> @torch.library.custom_op("mylib::foo", mutates_args={})
>>> def foo(x: torch.Tensor) -> torch.Tensor:
>>>     return x.clone()
>>>
>>> class MyMode(torch.utils._python_dispatch.TorchDispatchMode):
>>>     def __torch_dispatch__(self, func, types, args=(), kwargs=None):
>>>         return func(*args, **kwargs)
>>>
>>> @torch.library.register_torch_dispatch("mylib::foo", MyMode)
>>> def _(mode, func, types, args, kwargs):
>>>     x, = args
>>>     return x + 1
>>>
>>> x = torch.randn(3)
>>> y = foo(x)
>>> assert torch.allclose(y, x)
>>>
>>> with MyMode():
>>>     y = foo(x)
>>> assert torch.allclose(y, x + 1)

```
Copy to clipboard 

torch.library.infer_schema(_prototype_function_ , _/_ , _*_ , _mutates_args_ , _op_name =None_)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/_library/infer_schema.py#L18)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.infer_schema) 
    
Parses the schema of a given function with type hints. The schema is inferred from the function’s type hints, and can be used to define a new operator.
We make the following assumptions:
  * None of the outputs alias any of the inputs or each other.
  * String type annotations “device, dtype, Tensor, types” without library specification are
assumed to be torch.*. Similarly, string type annotations “Optional, List, Sequence, Union”
without library specification are assumed to be typing.*.
  * Only the args listed in `mutates_args` are being mutated. If `mutates_args` is “unknown”,
it assumes that all inputs to the operator are being mutates.


Callers (e.g. the custom ops API) are responsible for checking these assumptions. 

Parameters
    
  * **prototype_function** ([_Callable_](https://docs.python.org/3/library/typing.html#typing.Callable "\(in Python v3.13\)")) – The function from which to infer a schema for from its type annotations.
  * **op_name** (_Optional_ _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]_) – The name of the operator in the schema. If `name` is None, then the name is not included in the inferred schema. Note that the input schema to `torch.library.Library.define` requires a operator name.
  * **mutates_args** (_"unknown"__|__Iterable_ _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]_) – The arguments that are mutated in the function.



Returns
    
The inferred schema. 

Return type
    
[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")
Example
```
>>> def foo_impl(x: torch.Tensor) -> torch.Tensor:
>>>     return x.sin()
>>>
>>> infer_schema(foo_impl, op_name="foo", mutates_args={})
foo(Tensor x) -> Tensor
>>>
>>> infer_schema(foo_impl, mutates_args={})
(Tensor x) -> Tensor

```
Copy to clipboard 

_class_ torch._library.custom_ops.CustomOpDef(_namespace_ , _name_ , _schema_ , _fn_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/_library/custom_ops.html#CustomOpDef)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/_library/custom_ops.py#L176)[](https://docs.pytorch.org/docs/stable/library.html#torch._library.custom_ops.CustomOpDef) 
    
CustomOpDef is a wrapper around a function that turns it into a custom op.
It has various methods for registering additional behavior for this custom op.
You should not instantiate CustomOpDef directly; instead, use the [`torch.library.custom_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.custom_op "torch.library.custom_op") API. 

set_kernel_enabled(_device_type_ , _enabled =True_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/_library/custom_ops.html#CustomOpDef.set_kernel_enabled)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/_library/custom_ops.py#L215)[](https://docs.pytorch.org/docs/stable/library.html#torch._library.custom_ops.CustomOpDef.set_kernel_enabled) 
    
Disable or re-enable an already registered kernel for this custom operator.
If the kernel is already disabled/enabled, this is a no-op.
Note
If a kernel is first disabled and then registered, it is disabled until enabled again. 

Parameters
    
  * **device_type** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The device type to disable/enable the kernel for.
  * **disable** ([_bool_](https://docs.python.org/3/library/functions.html#bool "\(in Python v3.13\)")) – Whether to disable or enable the kernel.


Example
```
>>> inp = torch.randn(1)
>>>
>>> # define custom op `f`.
>>> @custom_op("mylib::f", mutates_args=())
>>> def f(x: Tensor) -> Tensor:
>>>     return torch.zeros(1)
>>>
>>> print(f(inp))  # tensor([0.]), default kernel
>>>
>>> @f.register_kernel("cpu")
>>> def _(x):
>>>     return torch.ones(1)
>>>
>>> print(f(inp))  # tensor([1.]), CPU kernel
>>>
>>> # temporarily disable the CPU kernel
>>> with f.set_kernel_enabled("cpu", enabled = False):
>>>     print(f(inp))  # tensor([0.]) with CPU kernel disabled

```
Copy to clipboard
## Low-level APIs[](https://docs.pytorch.org/docs/stable/library.html#low-level-apis)
The following APIs are direct bindings to PyTorch’s C++ low-level operator registration APIs.
Warning
The low-level operator registration APIs and the PyTorch Dispatcher are a complicated PyTorch concept. We recommend you use the higher level APIs above (that do not require a torch.library.Library object) when possible. This blog post <<http://blog.ezyang.com/2020/09/lets-talk-about-the-pytorch-dispatcher/>>`_ is a good starting point to learn about the PyTorch Dispatcher.
A tutorial that walks you through some examples on how to use this API is available on [Google Colab](https://colab.research.google.com/drive/1RRhSfk7So3Cn02itzLWE9K4Fam-8U011?usp=sharing). 

_class_ torch.library.Library(_ns_ , _kind_ , _dispatch_key =''_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#Library)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L75)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library) 
    
A class to create libraries that can be used to register new operators or override operators in existing libraries from Python. A user can optionally pass in a dispatch keyname if they only want to register kernels corresponding to only one specific dispatch key.
To create a library to override operators in an existing library (with name ns), set the kind to “IMPL”. To create a new library (with name ns) to register new operators, set the kind to “DEF”. To create a fragment of a possibly existing library to register operators (and bypass the limitation that there is only one library for a given namespace), set the kind to “FRAGMENT”. 

Parameters
    
  * **ns** – library name
  * **kind** – “DEF”, “IMPL” (default: “IMPL”), “FRAGMENT”
  * **dispatch_key** – PyTorch dispatch key (default: “”)



define(_schema_ , _alias_analysis =''_, _*_ , _tags =()_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#Library.define)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L135)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library.define) 
    
Defines a new operator and its semantics in the ns namespace. 

Parameters
    
  * **schema** – function schema to define a new operator.
  * **alias_analysis** (_optional_) – Indicates if the aliasing properties of the operator arguments can be inferred from the schema (default behavior) or not (“CONSERVATIVE”).
  * **tags** ([_Tag_](https://docs.pytorch.org/docs/stable/torch.html#torch.Tag "torch.Tag") _|__Sequence_ _[_[_Tag_](https://docs.pytorch.org/docs/stable/torch.html#torch.Tag "torch.Tag") _]_) – one or more torch.Tag to apply to this operator. Tagging an operator changes the operator’s behavior under various PyTorch subsystems; please read the docs for the torch.Tag carefully before applying it.



Returns
    
name of the operator as inferred from the schema. 

Example::
    
```
>>> my_lib = Library("mylib", "DEF")
>>> my_lib.define("sum(Tensor self) -> Tensor")

```
Copy to clipboard 

fallback(_fn_ , _dispatch_key =''_, _*_ , _with_keyset =False_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#Library.fallback)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L375)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library.fallback) 
    
Registers the function implementation as the fallback for the given key.
This function only works for a library with global namespace (“_”). 

Parameters
    
  * **fn** – function used as fallback for the given dispatch key or [`fallthrough_kernel()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.fallthrough_kernel "torch.library.fallthrough_kernel") to register a fallthrough.
  * **dispatch_key** – dispatch key that the input function should be registered for. By default, it uses the dispatch key that the library was created with.
  * **with_keyset** – flag controlling if the current dispatcher call keyset should be passed as the first argument to `fn` when calling. This should be used to create the appropriate keyset for redispatch calls.



Example::
    
```
>>> my_lib = Library("_", "IMPL")
>>> def fallback_kernel(op, *args, **kwargs):
>>>     # Handle all autocast ops generically
>>>     # ...
>>> my_lib.fallback(fallback_kernel, "Autocast")

```
Copy to clipboard 

impl(_op_name_ , _fn_ , _dispatch_key =''_, _*_ , _with_keyset =False_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#Library.impl)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L293)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library.impl) 
    
Registers the function implementation for an operator defined in the library. 

Parameters
    
  * **op_name** – operator name (along with the overload) or OpOverload object.
  * **fn** – function that’s the operator implementation for the input dispatch key or [`fallthrough_kernel()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.fallthrough_kernel "torch.library.fallthrough_kernel") to register a fallthrough.
  * **dispatch_key** – dispatch key that the input function should be registered for. By default, it uses the dispatch key that the library was created with.
  * **with_keyset** – flag controlling if the current dispatcher call keyset should be passed as the first argument to `fn` when calling. This should be used to create the appropriate keyset for redispatch calls.



Example::
    
```
>>> my_lib = Library("aten", "IMPL")
>>> def div_cpu(self, other):
>>>     return self * (1 / other)
>>> my_lib.impl("div.Tensor", div_cpu, "CPU")

```
Copy to clipboard 

torch.library.fallthrough_kernel()[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#fallthrough_kernel)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L68)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.fallthrough_kernel) 
    
A dummy function to pass to `Library.impl` in order to register a fallthrough. 

torch.library.define(_qualname_ , _schema_ , _*_ , _lib =None_, _tags =()_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#define)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L467)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.define) 


torch.library.define(_lib_ , _schema_ , _alias_analysis =''_) 
    
Defines a new operator.
In PyTorch, defining an op (short for “operator”) is a two step-process: - we need to define the op (by providing an operator name and schema) - we need to implement behavior for how the operator interacts with various PyTorch subsystems, like CPU/CUDA Tensors, Autograd, etc.
This entrypoint defines the custom operator (the first step) you must then perform the second step by calling various `impl_*` APIs, like [`torch.library.impl()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.impl "torch.library.impl") or [`torch.library.register_fake()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_fake "torch.library.register_fake"). 

Parameters
    
  * **qualname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The qualified name for the operator. Should be a string that looks like “namespace::name”, e.g. “aten::sin”. Operators in PyTorch need a namespace to avoid name collisions; a given operator may only be created once. If you are writing a Python library, we recommend the namespace to be the name of your top-level module.
  * **schema** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – The schema of the operator. E.g. “(Tensor x) -> Tensor” for an op that accepts one Tensor and returns one Tensor. It does not contain the operator name (that is passed in `qualname`).
  * **lib** (_Optional_ _[_[_Library_](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library "torch.library.Library") _]_) – If provided, the lifetime of this operator will be tied to the lifetime of the Library object.
  * **tags** ([_Tag_](https://docs.pytorch.org/docs/stable/torch.html#torch.Tag "torch.Tag") _|__Sequence_ _[_[_Tag_](https://docs.pytorch.org/docs/stable/torch.html#torch.Tag "torch.Tag") _]_) – one or more torch.Tag to apply to this operator. Tagging an operator changes the operator’s behavior under various PyTorch subsystems; please read the docs for the torch.Tag carefully before applying it.



Example::
    
```
>>> import torch
>>> import numpy as np
>>>
>>> # Define the operator
>>> torch.library.define("mylib::sin", "(Tensor x) -> Tensor")
>>>
>>> # Add implementations for the operator
>>> @torch.library.impl("mylib::sin", "cpu")
>>> def f(x):
>>>     return torch.from_numpy(np.sin(x.numpy()))
>>>
>>> # Call the new operator from torch.ops.
>>> x = torch.randn(3)
>>> y = torch.ops.mylib.sin(x)
>>> assert torch.allclose(y, x.sin())

```
Copy to clipboard 

torch.library.impl(_lib_ , _name_ , _dispatch_key =''_)[[source]](https://docs.pytorch.org/docs/stable/_modules/torch/library.html#impl)[[source]](https://github.com/pytorch/pytorch/blob/v2.7.0/torch/library.py#L577)[](https://docs.pytorch.org/docs/stable/library.html#torch.library.impl) 


torch.library.impl(_qualname :[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_, _types :Union[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"),Sequence[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]_, _func :Literal[None]=None_, _*_ , _lib :Optional[[Library](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library "torch.library.Library")]=None_) → Callable[[Callable[...,[object](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")]],[None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)")] 


torch.library.impl(_qualname :[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_, _types :Union[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)"),Sequence[[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")]]_, _func :Callable[...,[object](https://docs.python.org/3/library/functions.html#object "\(in Python v3.13\)")]_, _*_ , _lib :Optional[[Library](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library "torch.library.Library")]=None_) → [None](https://docs.python.org/3/library/constants.html#None "\(in Python v3.13\)") 


torch.library.impl(_lib :[Library](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library "torch.library.Library")_, _name :[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")_, _dispatch_key :[str](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")=''_) → Callable[[Callable[_P,_T]],Callable[_P,_T]] 
    
Register an implementation for a device type for this operator.
You may pass “default” for `types` to register this implementation as the default implementation for ALL device types. Please only use this if the implementation truly supports all device types; for example, this is true if it is a composition of built-in PyTorch operators.
This API may be used as a decorator. You can use nested decorators with this API provided they return a function and are placed inside this API (see Example 2).
Some valid types are: “cpu”, “cuda”, “xla”, “mps”, “ipu”, “xpu”. 

Parameters
    
  * **qualname** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)")) – Should be a string that looks like “namespace::operator_name”.
  * **types** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _|__Sequence_ _[_[_str_](https://docs.python.org/3/library/stdtypes.html#str "\(in Python v3.13\)") _]_) – The device types to register an impl to.
  * **lib** (_Optional_ _[_[_Library_](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library "torch.library.Library") _]_) – If provided, the lifetime of this registration will be tied to the lifetime of the Library object.


Examples
```
>>> import torch
>>> import numpy as np
>>> # Example 1: Register function.
>>> # Define the operator
>>> torch.library.define("mylib::mysin", "(Tensor x) -> Tensor")
>>>
>>> # Add implementations for the cpu device
>>> @torch.library.impl("mylib::mysin", "cpu")
>>> def f(x):
>>>     return torch.from_numpy(np.sin(x.numpy()))
>>>
>>> x = torch.randn(3)
>>> y = torch.ops.mylib.mysin(x)
>>> assert torch.allclose(y, x.sin())
>>>
>>> # Example 2: Register function with decorator.
>>> def custom_decorator(func):
>>>     def wrapper(*args, **kwargs):
>>>         return func(*args, **kwargs) + 1
>>>     return wrapper
>>>
>>> # Define the operator
>>> torch.library.define("mylib::sin_plus_one", "(Tensor x) -> Tensor")
>>>
>>> # Add implementations for the operator
>>> @torch.library.impl("mylib::sin_plus_one", "cpu")
>>> @custom_decorator
>>> def f(x):
>>>     return torch.from_numpy(np.sin(x.numpy()))
>>>
>>> # Call the new operator from torch.ops.
>>> x = torch.randn(3)
>>>
>>> y1 = torch.ops.mylib.sin_plus_one(x)
>>> y2 = torch.sin(x) + 1
>>> assert torch.allclose(y1, y2)

```
Copy to clipboard
[Next ![](https://docs.pytorch.org/docs/stable/_static/images/chevron-right-orange.svg)](https://docs.pytorch.org/docs/stable/accelerator.html "torch.accelerator") [![](https://docs.pytorch.org/docs/stable/_static/images/chevron-right-orange.svg) Previous](https://docs.pytorch.org/docs/stable/generated/torch.autograd.graph.increment_version.html "torch.autograd.graph.increment_version")
* * *
© Copyright PyTorch Contributors. 
Built with [Sphinx](http://sphinx-doc.org/) using a [theme](https://github.com/rtfd/sphinx_rtd_theme) provided by [Read the Docs](https://readthedocs.org). 
  * [torch.library](https://docs.pytorch.org/docs/stable/library.html)
    * [Testing custom ops](https://docs.pytorch.org/docs/stable/library.html#testing-custom-ops)
      * [`opcheck()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.opcheck)
    * [Creating new custom ops in Python](https://docs.pytorch.org/docs/stable/library.html#creating-new-custom-ops-in-python)
      * [`custom_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.custom_op)
      * [`triton_op()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.triton_op)
      * [`wrap_triton()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.wrap_triton)
    * [Extending custom ops (created from Python or C++)](https://docs.pytorch.org/docs/stable/library.html#extending-custom-ops-created-from-python-or-c)
      * [`register_kernel()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_kernel)
      * [`register_autocast()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_autocast)
      * [`register_autograd()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_autograd)
      * [`register_fake()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_fake)
      * [`register_vmap()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_vmap)
      * [`impl_abstract()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.impl_abstract)
      * [`get_ctx()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.get_ctx)
      * [`register_torch_dispatch()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.register_torch_dispatch)
      * [`infer_schema()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.infer_schema)
      * [`CustomOpDef`](https://docs.pytorch.org/docs/stable/library.html#torch._library.custom_ops.CustomOpDef)
        * [`CustomOpDef.set_kernel_enabled()`](https://docs.pytorch.org/docs/stable/library.html#torch._library.custom_ops.CustomOpDef.set_kernel_enabled)
    * [Low-level APIs](https://docs.pytorch.org/docs/stable/library.html#low-level-apis)
      * [`Library`](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library)
        * [`Library.define()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library.define)
        * [`Library.fallback()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library.fallback)
        * [`Library.impl()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.Library.impl)
      * [`fallthrough_kernel()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.fallthrough_kernel)
      * [`define()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.define)
      * [`impl()`](https://docs.pytorch.org/docs/stable/library.html#torch.library.impl)


![](https://www.googleadservices.com/pagead/conversion/795629140/?label=txkmCPmdtosBENSssfsC&guid=ON&script=0)
## Docs
Access comprehensive developer documentation for PyTorch
[View Docs](https://pytorch.org/docs/stable/index.html)
## Tutorials
Get in-depth tutorials for beginners and advanced developers
[View Tutorials](https://pytorch.org/tutorials)
## Resources
Find development resources and get your questions answered
[View Resources](https://pytorch.org/resources)
[](https://pytorch.org/)
  * [PyTorch](https://pytorch.org/)
  * [Get Started](https://pytorch.org/get-started)
  * [Features](https://pytorch.org/features)
  * [Ecosystem](https://pytorch.org/ecosystem)
  * [Blog](https://pytorch.org/blog/)
  * [Contributing](https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md)


  * [Resources](https://pytorch.org/resources)
  * [Tutorials](https://pytorch.org/tutorials)
  * [Docs](https://pytorch.org/docs/stable/index.html)
  * [Discuss](https://discuss.pytorch.org)
  * [Github Issues](https://github.com/pytorch/pytorch/issues)
  * [Brand Guidelines](https://pytorch.org/assets/brand-guidelines/PyTorch-Brand-Guidelines.pdf)


  * Stay up to date
  * [Facebook](https://www.facebook.com/pytorch)
  * [Twitter](https://twitter.com/pytorch)
  * [YouTube](https://www.youtube.com/pytorch)
  * [LinkedIn](https://www.linkedin.com/company/pytorch)


  * PyTorch Podcasts
  * [Spotify](https://open.spotify.com/show/6UzHKeiy368jKfQMKKvJY5)
  * [Apple](https://podcasts.apple.com/us/podcast/pytorch-developer-podcast/id1566080008)
  * [Google](https://www.google.com/podcasts?feed=aHR0cHM6Ly9mZWVkcy5zaW1wbGVjYXN0LmNvbS9PQjVGa0lsOA%3D%3D)
  * [Amazon](https://music.amazon.com/podcasts/7a4e6f0e-26c2-49e9-a478-41bd244197d0/PyTorch-Developer-Podcast)


  * [Terms](https://www.linuxfoundation.org/terms/)
  * |
  * [Privacy](https://www.linuxfoundation.org/privacy-policy/)


© Copyright The Linux Foundation. The PyTorch Foundation is a project of The Linux Foundation. For web site terms of use, trademark policy and other policies applicable to The PyTorch Foundation please see [www.linuxfoundation.org/policies/](https://www.linuxfoundation.org/policies/). The PyTorch Foundation supports the PyTorch open source project, which has been established as PyTorch Project a Series of LF Projects, LLC. For policies applicable to the PyTorch Project a Series of LF Projects, LLC, please see [www.lfprojects.org/policies/](https://www.lfprojects.org/policies/).
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebook’s Cookies Policy applies. Learn more, including about available controls: [Cookies Policy](https://www.facebook.com/policies/cookies/).
![](https://docs.pytorch.org/docs/stable/_static/images/pytorch-x.svg)
[](https://pytorch.org/) [](https://docs.pytorch.org/docs/stable/library.html)
  * Learn
    * [Get Started](https://pytorch.org/get-started)
    * [Tutorials](https://pytorch.org/tutorials)
    * [Learn the Basics](https://pytorch.org/tutorials/beginner/basics/intro.html)
    * [PyTorch Recipes](https://pytorch.org/tutorials/recipes/recipes_index.html)
    * [Introduction to PyTorch - YouTube Series](https://pytorch.org/tutorials/beginner/introyt.html)
  * Ecosystem
    * [Tools](https://pytorch.org/ecosystem)
    * [Community](https://pytorch.org/#community-module)
    * [Forums](https://discuss.pytorch.org/)
    * [Developer Resources](https://pytorch.org/resources)
    * [Contributor Awards - 2024](https://pytorch.org/ecosystem/contributor-awards-2023)
  * Edge
    * [About PyTorch Edge](https://pytorch.org/edge)
    * [ExecuTorch](https://pytorch.org/executorch-overview)
    * [ExecuTorch Documentation](https://pytorch.org/executorch/stable/index.html)
  * Docs
    * [PyTorch](https://pytorch.org/docs/stable/index.html)
    * [PyTorch Domains](https://pytorch.org/pytorch-domains)
  * Blog & News
    * [PyTorch Blog](https://pytorch.org/blog/)
    * [Community Blog](https://pytorch.org/community-blog)
    * [Videos](https://pytorch.org/videos)
    * [Community Stories](https://pytorch.org/community-stories)
    * [Events](https://pytorch.org/events)
    * [Newsletter](https://pytorch.org/newsletter)
  * About
    * [PyTorch Foundation](https://pytorch.org/foundation)
    * [Governing Board](https://pytorch.org/governing-board)
    * [Cloud Credit Program](https://pytorch.org/credits)
    * [Technical Advisory Council](https://pytorch.org/tac)
    * [Staff](https://pytorch.org/staff)
    * [Contact Us](https://pytorch.org/contact-us)


|   
---|---
